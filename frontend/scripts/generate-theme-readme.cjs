const fs = require("fs");
const path = require("path");

const ROOT = path.resolve(__dirname, "..");
const THEME_DIR = path.join(ROOT, "src", "theme");
const COMPONENTS_DIR = path.join(ROOT, "src", "components");
const README_PATH = path.join(THEME_DIR, "README.md");

const START = "<!-- AUTO-GENERATED:START -->";
const END = "<!-- AUTO-GENERATED:END -->";

function readText(p) {
  return fs.readFileSync(p, "utf8");
}

function writeText(p, content) {
  fs.writeFileSync(p, content, "utf8");
}

function safeListDir(dir) {
  if (!fs.existsSync(dir)) return [];
  return fs
    .readdirSync(dir)
    .filter((f) => !f.startsWith("."))
    .sort((a, b) => a.localeCompare(b));
}

function listFilesRecursive(dir, exts) {
  const out = [];
  if (!fs.existsSync(dir)) return out;

  for (const entry of fs.readdirSync(dir, { withFileTypes: true })) {
    const abs = path.join(dir, entry.name);
    if (entry.isDirectory()) {
      out.push(...listFilesRecursive(abs, exts));
    } else if (entry.isFile()) {
      const ext = path.extname(entry.name).toLowerCase();
      if (exts.includes(ext)) out.push(abs);
    }
  }
  return out;
}

function toRel(p) {
  return path.relative(ROOT, p).replace(/\\/g, "/");
}

function extractExports(fileContent) {
  // Best-effort, intentionally simple.
  // Matches: export function X, export const X, export type X, export interface X
  const exports = new Set();
  const re = /export\s+(?:async\s+)?(?:function|const|type|interface|class)\s+([A-Za-z0-9_]+)/g;
  let m;
  while ((m = re.exec(fileContent))) {
    exports.add(m[1]);
  }
  return [...exports].sort((a, b) => a.localeCompare(b));
}

function extractThemeSummary(themesTs) {
  const out = [];

  const lightGradient = themesTs.match(/lightTheme[\s\S]*?gradient:\s*\[(.*?)\]/m);
  const darkGradient = themesTs.match(/darkTheme[\s\S]*?gradient:\s*\[(.*?)\]/m);

  if (lightGradient) out.push(`- **Light gradient**: [${lightGradient[1].trim()}]`);
  if (darkGradient) out.push(`- **Dark gradient**: [${darkGradient[1].trim()}]`);

  return out.join("\n");
}

function generateAutoSection() {
  const themeFiles = safeListDir(THEME_DIR).filter((f) => f.endsWith(".ts") || f.endsWith(".tsx"));
  const componentFiles = safeListDir(COMPONENTS_DIR).filter((f) => f.endsWith(".ts") || f.endsWith(".tsx"));

  const themesTsPath = path.join(THEME_DIR, "themes.ts");
  const themesTs = fs.existsSync(themesTsPath) ? readText(themesTsPath) : "";

  const themedComponentAbs = listFilesRecursive(COMPONENTS_DIR, [".ts", ".tsx"]).filter((p) =>
    path.basename(p).startsWith("Themed")
  );

  const componentTableRows = themedComponentAbs
    .map((p) => {
      const content = readText(p);
      const exports = extractExports(content).filter((e) => e !== "default");
      return {
        file: toRel(p),
        exports
      };
    })
    .sort((a, b) => a.file.localeCompare(b.file));

  return [
    "## Auto-generated reference",
    "",
    `This section is generated by: \`${toRel(path.join(ROOT, "scripts", "generate-theme-readme.cjs"))}\`.
Run: \`npm run theme:docs\` to refresh it.`,
    "",
    "### Theme summary (from src/theme/themes.ts)",
    "",
    extractThemeSummary(themesTs) || "- (No summary extracted)",
    "",
    "### Theme files", 
    "",
    ...themeFiles.map((f) => `- \`${toRel(path.join(THEME_DIR, f))}\``),
    "",
    "### Components folder", 
    "",
    ...componentFiles.map((f) => `- \`${toRel(path.join(COMPONENTS_DIR, f))}\``),
    "",
    "### Themed components (exports)",
    "",
    "| File | Exports |",
    "| --- | --- |",
    ...componentTableRows.map((r) => `| \`${r.file}\` | ${r.exports.map((e) => `\`${e}\``).join(", ") || "(none)"} |`),
    ""
  ].join("\n");
}

function updateReadme() {
  if (!fs.existsSync(README_PATH)) {
    throw new Error(`README not found at ${README_PATH}`);
  }

  const original = readText(README_PATH);
  const startIdx = original.indexOf(START);
  const endIdx = original.indexOf(END);

  if (startIdx === -1 || endIdx === -1 || endIdx < startIdx) {
    throw new Error(
      `README must include both markers:\n${START}\n${END}\n` +
        `Add them once, then re-run the generator.`
    );
  }

  const before = original.slice(0, startIdx + START.length);
  const after = original.slice(endIdx);

  const generated = generateAutoSection();
  const next = `${before}\n\n${generated}\n\n${after}`;

  writeText(README_PATH, next);
}

try {
  updateReadme();
  // eslint-disable-next-line no-console
  console.log("Theme README updated:", README_PATH);
} catch (err) {
  // eslint-disable-next-line no-console
  console.error(err instanceof Error ? err.message : String(err));
  process.exit(1);
}
